{"backend_state":"running","connection_file":"/projects/7054eb54-2282-47cc-9fd4-f73d8c0d026c/.local/share/jupyter/runtime/kernel-ef8f3fc4-71c5-4818-a671-94627d580bcf.json","kernel":"cv_env","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"colab":{"collapsed_sections":[],"name":"aicamp_face_recognition.ipynb","provenance":[]}},"trust":true,"type":"settings"}
{"cell_type":"code","end":1658336521508,"exec_count":13,"id":"78f112","input":"#import dependencies\nimport cv2\nfrom skimage import io\nimport matplotlib.pyplot as plt\n\n#get the cascade classifier from the cv2 filepath\nfaceCascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')\n\n#url of the image\nurl = \"https://www.shutterstock.com/search/people\"\n\n#read the picture from the url and turn it to BGR format\npicture = io.imread(url)\n\n# Detect faces in the image\nfaces = faceCascade.detectMultiScale(\n    picture,\n    scaleFactor=1.1,\n    minNeighbors=5,\n    minSize=(30, 30),\n    flags = cv2.CASCADE_SCALE_IMAGE\n)\n#print the number of faces found\nprint(f\"Found {len(faces)} faces!\")\n\n# Draw a rectangle around the faces\n\nfor (x, y, w, h) in faces:\n    cv2.rectangle(picture, (x, y), (x+w, y+h), (0, 255, 0), 2)\n#   cv2.rectangle(image, start_point, end_point, color, thickness)\n#show the image with the rectangle drawn around it\n#plt.axis(\"off\")\nplt.imshow(picture)\nplt.show()\nprint(faces)","kernel":"cv_env","metadata":{"vscode":{"languageId":"python"}},"output":{"0":{"ename":"ValueError","evalue":"Could not find a backend to open `/tmp/tmp0qbxtmgv`` with iomode `ri`.","traceback":["\u001b[0;31m---------------------------------------------------------------------------\u001b[0m","\u001b[0;31mValueError\u001b[0m                                Traceback (most recent call last)","Input \u001b[0;32mIn [13]\u001b[0m, in \u001b[0;36m<cell line: 13>\u001b[0;34m()\u001b[0m\n\u001b[1;32m     10\u001b[0m url \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mhttps://www.shutterstock.com/search/people\u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m     12\u001b[0m \u001b[38;5;66;03m#read the picture from the url and turn it to BGR format\u001b[39;00m\n\u001b[0;32m---> 13\u001b[0m picture \u001b[38;5;241m=\u001b[39m \u001b[43mio\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mimread\u001b[49m\u001b[43m(\u001b[49m\u001b[43murl\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m     15\u001b[0m \u001b[38;5;66;03m# Detect faces in the image\u001b[39;00m\n\u001b[1;32m     16\u001b[0m faces \u001b[38;5;241m=\u001b[39m faceCascade\u001b[38;5;241m.\u001b[39mdetectMultiScale(\n\u001b[1;32m     17\u001b[0m     picture,\n\u001b[1;32m     18\u001b[0m     scaleFactor\u001b[38;5;241m=\u001b[39m\u001b[38;5;241m1.1\u001b[39m,\n\u001b[0;32m   (...)\u001b[0m\n\u001b[1;32m     21\u001b[0m     flags \u001b[38;5;241m=\u001b[39m cv2\u001b[38;5;241m.\u001b[39mCASCADE_SCALE_IMAGE\n\u001b[1;32m     22\u001b[0m )\n","File \u001b[0;32m~/miniconda3/envs/cv_env/lib/python3.8/site-packages/skimage/io/_io.py:53\u001b[0m, in \u001b[0;36mimread\u001b[0;34m(fname, as_gray, plugin, **plugin_args)\u001b[0m\n\u001b[1;32m     50\u001b[0m         plugin \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mtifffile\u001b[39m\u001b[38;5;124m'\u001b[39m\n\u001b[1;32m     52\u001b[0m \u001b[38;5;28;01mwith\u001b[39;00m file_or_url_context(fname) \u001b[38;5;28;01mas\u001b[39;00m fname:\n\u001b[0;32m---> 53\u001b[0m     img \u001b[38;5;241m=\u001b[39m \u001b[43mcall_plugin\u001b[49m\u001b[43m(\u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mimread\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfname\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mplugin\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mplugin\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[43mplugin_args\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m     55\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28mhasattr\u001b[39m(img, \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mndim\u001b[39m\u001b[38;5;124m'\u001b[39m):\n\u001b[1;32m     56\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m img\n","File \u001b[0;32m~/miniconda3/envs/cv_env/lib/python3.8/site-packages/skimage/io/manage_plugins.py:207\u001b[0m, in \u001b[0;36mcall_plugin\u001b[0;34m(kind, *args, **kwargs)\u001b[0m\n\u001b[1;32m    203\u001b[0m     \u001b[38;5;28;01mexcept\u001b[39;00m \u001b[38;5;167;01mIndexError\u001b[39;00m:\n\u001b[1;32m    204\u001b[0m         \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;167;01mRuntimeError\u001b[39;00m(\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mCould not find the plugin \u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;132;01m%s\u001b[39;00m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124m for \u001b[39m\u001b[38;5;132;01m%s\u001b[39;00m\u001b[38;5;124m.\u001b[39m\u001b[38;5;124m'\u001b[39m \u001b[38;5;241m%\u001b[39m\n\u001b[1;32m    205\u001b[0m                            (plugin, kind))\n\u001b[0;32m--> 207\u001b[0m \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43mfunc\u001b[49m\u001b[43m(\u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[43margs\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[43mkwargs\u001b[49m\u001b[43m)\u001b[49m\n","File \u001b[0;32m~/miniconda3/envs/cv_env/lib/python3.8/site-packages/skimage/io/_plugins/imageio_plugin.py:10\u001b[0m, in \u001b[0;36mimread\u001b[0;34m(*args, **kwargs)\u001b[0m\n\u001b[1;32m      8\u001b[0m \u001b[38;5;129m@wraps\u001b[39m(imageio_imread)\n\u001b[1;32m      9\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m \u001b[38;5;21mimread\u001b[39m(\u001b[38;5;241m*\u001b[39margs, \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwargs):\n\u001b[0;32m---> 10\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m np\u001b[38;5;241m.\u001b[39masarray(\u001b[43mimageio_imread\u001b[49m\u001b[43m(\u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[43margs\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[43mkwargs\u001b[49m\u001b[43m)\u001b[49m)\n","File \u001b[0;32m~/miniconda3/envs/cv_env/lib/python3.8/site-packages/imageio/__init__.py:97\u001b[0m, in \u001b[0;36mimread\u001b[0;34m(uri, format, **kwargs)\u001b[0m\n\u001b[1;32m     68\u001b[0m \u001b[38;5;124;03m\"\"\"imread(uri, format=None, **kwargs)\u001b[39;00m\n\u001b[1;32m     69\u001b[0m \n\u001b[1;32m     70\u001b[0m \u001b[38;5;124;03mReads an image from the specified file. Returns a numpy array, which\u001b[39;00m\n\u001b[0;32m   (...)\u001b[0m\n\u001b[1;32m     86\u001b[0m \u001b[38;5;124;03m    to see what arguments are available for a particular format.\u001b[39;00m\n\u001b[1;32m     87\u001b[0m \u001b[38;5;124;03m\"\"\"\u001b[39;00m\n\u001b[1;32m     89\u001b[0m warnings\u001b[38;5;241m.\u001b[39mwarn(\n\u001b[1;32m     90\u001b[0m     \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mStarting with ImageIO v3 the behavior of this function will switch to that of\u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m     91\u001b[0m     \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124m iio.v3.imread. To keep the current behavior (and make this warning dissapear)\u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[0;32m   (...)\u001b[0m\n\u001b[1;32m     94\u001b[0m     stacklevel\u001b[38;5;241m=\u001b[39m\u001b[38;5;241m2\u001b[39m,\n\u001b[1;32m     95\u001b[0m )\n\u001b[0;32m---> 97\u001b[0m \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43mimread_v2\u001b[49m\u001b[43m(\u001b[49m\u001b[43muri\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;28;43mformat\u001b[39;49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[38;5;28;43mformat\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[43mkwargs\u001b[49m\u001b[43m)\u001b[49m\n","File \u001b[0;32m~/miniconda3/envs/cv_env/lib/python3.8/site-packages/imageio/v2.py:200\u001b[0m, in \u001b[0;36mimread\u001b[0;34m(uri, format, **kwargs)\u001b[0m\n\u001b[1;32m    197\u001b[0m imopen_args \u001b[38;5;241m=\u001b[39m decypher_format_arg(\u001b[38;5;28mformat\u001b[39m)\n\u001b[1;32m    198\u001b[0m imopen_args[\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mlegacy_mode\u001b[39m\u001b[38;5;124m\"\u001b[39m] \u001b[38;5;241m=\u001b[39m \u001b[38;5;28;01mTrue\u001b[39;00m\n\u001b[0;32m--> 200\u001b[0m \u001b[38;5;28;01mwith\u001b[39;00m \u001b[43mimopen\u001b[49m\u001b[43m(\u001b[49m\u001b[43muri\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43mri\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[43mimopen_args\u001b[49m\u001b[43m)\u001b[49m \u001b[38;5;28;01mas\u001b[39;00m file:\n\u001b[1;32m    201\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m file\u001b[38;5;241m.\u001b[39mread(index\u001b[38;5;241m=\u001b[39m\u001b[38;5;241m0\u001b[39m, \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwargs)\n","File \u001b[0;32m~/miniconda3/envs/cv_env/lib/python3.8/site-packages/imageio/core/imopen.py:303\u001b[0m, in \u001b[0;36mimopen\u001b[0;34m(uri, io_mode, plugin, extension, format_hint, legacy_mode, **kwargs)\u001b[0m\n\u001b[1;32m    297\u001b[0m         err_msg \u001b[38;5;241m+\u001b[39m\u001b[38;5;241m=\u001b[39m (\n\u001b[1;32m    298\u001b[0m             \u001b[38;5;124m\"\u001b[39m\u001b[38;5;130;01m\\n\u001b[39;00m\u001b[38;5;124mBased on the extension, the following plugins might add capable backends:\u001b[39m\u001b[38;5;130;01m\\n\u001b[39;00m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m    299\u001b[0m             \u001b[38;5;124mf\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;132;01m{\u001b[39;00minstall_candidates\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m    300\u001b[0m         )\n\u001b[1;32m    302\u001b[0m request\u001b[38;5;241m.\u001b[39mfinish()\n\u001b[0;32m--> 303\u001b[0m \u001b[38;5;28;01mraise\u001b[39;00m err_type(err_msg)\n","\u001b[0;31mValueError\u001b[0m: Could not find a backend to open `/tmp/tmp0qbxtmgv`` with iomode `ri`."]},"1":{"data":{"image/png":"39cfaf3464ce9814b830e1c71a2e76b991503e89","text/plain":"<Figure size 432x288 with 1 Axes>"},"metadata":{"needs_background":"light"}},"2":{"name":"stdout","text":"[[219  48  51  51]\n [ 54  39  53  53]\n [306  44  54  54]\n [129  70  49  49]]\n"}},"pos":15,"scrolled":true,"start":1658336520257,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":2,"id":"4a8919","input":"","kernel":"cv_env","metadata":{"id":"3AeOvLI76slQ","vscode":{"languageId":"python"}},"no_halt":true,"pos":4,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":3,"id":"4d41df","input":"","kernel":"cv_env","metadata":{"id":"rvtpyzf48e_r","vscode":{"languageId":"python"}},"no_halt":true,"pos":6,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":4,"id":"6d304e","input":"","kernel":"cv_env","metadata":{"colab":{"base_uri":"https://localhost:8080/","height":248},"id":"Dr_8wri_5Y_z","outputId":"03a9bca6-f0f9-4208-963f-e2aca56329ad","vscode":{"languageId":"python"}},"no_halt":true,"output":{"0":{"data":{"image/png":"b82f3569b7b0ed6b8b5fd85cc4ada1b234f73775","text/plain":"<Figure size 432x288 with 1 Axes>"},"metadata":{"needs_background":"light"}}},"pos":8,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":5,"id":"861378","input":"","kernel":"cv_env","metadata":{"colab":{"base_uri":"https://localhost:8080/","height":248},"id":"DiclYgTz5gXN","outputId":"6d26173c-3062-48a6-dadf-2814787c3130","vscode":{"languageId":"python"}},"no_halt":true,"output":{"0":{"data":{"image/png":"ed54dd3b23ed827cf125f84c001020a6ca0db3db","text/plain":"<Figure size 432x288 with 1 Axes>"},"metadata":{"needs_background":"light"}}},"pos":9,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":6,"id":"213003","input":"","kernel":"cv_env","metadata":{"id":"qOH1m1Z69J9h","vscode":{"languageId":"python"}},"no_halt":true,"pos":11,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":7,"id":"0bc648","input":"","kernel":"cv_env","metadata":{"colab":{"base_uri":"https://localhost:8080/","height":265},"id":"Vx2rUAOH9N6p","outputId":"8e0c08b1-d83d-4bfe-bdff-cc4887bc32fb","vscode":{"languageId":"python"}},"no_halt":true,"output":{"0":{"name":"stdout","text":"Found 4 faces!\n"},"1":{"data":{"image/png":"ff7b491786c0f84a9c70fb2f0682bc4746125318","text/plain":"<Figure size 432x288 with 1 Axes>"},"metadata":{"needs_background":"light"}}},"pos":13,"state":"done","type":"cell"}
{"cell_type":"code","id":"76e34b","input":"","kernel":"cv_env","metadata":{"id":"MvO5PwWjmXDl","vscode":{"languageId":"python"}},"no_halt":true,"pos":2,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"2abff6","input":"## Try some images of your own.\n\nThere are some other images in this folder you can experiment with, or you can use your own image to try and detect faces!\n\n","pos":14,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"375f3e","input":"## Displaying the Image\n\nWe set axis to off to avoid the annoying tickmarks on the x and y axis of a pyplot plot. We then use the pyplot imshow and then show functions to show the image. We also want to view the grayscale version of the image so we do the same thing but set the image color map parameter to gray.\n\n","metadata":{"id":"2wpc7TRomH3O"},"pos":7,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"656575","input":"### Preprocessing the Image\n\nWe first use the io.imread() function to get the image from the url. However, we need to convert it to grayscale format because we are using the OpenCV classifier. The io image originally comes in RGB color. This is the image we will use to display the boxes around the faces. We also need to convert the image to grayscale as the OpenCV model only works on grayscale faces. \n\n","metadata":{"id":"PXRqLJQ58el8"},"pos":5,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"6a4795","input":"### Getting the Image and Classifier\n\nHere we will get the face detector from the OpenCV library and store it in the faceCascade library. We then put the image address/url of the image. The example url below is an image of a group of four people. If you want, you can also upload a picture of yourself to google colab and put the filepath instead of the url to run facial detection on images from your own computer. \n\n","metadata":{"id":"6VqccN6i7k3c"},"pos":3,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"8bbc60","input":"### Detect the Faces\n\nWe execute the detectMultiScale method to detect the faces. \n\n* The first input is the **grayscale image** we want to use for detection. \n\n* **scaleFactor** is used if the image is too large and we make it smaller by a factor of 1.1 as the face detector can only detect faces in a certain range of sizes.\n \n* **minNeighbors** is one of the most important parameters in the model. Remember, the image is first split into many small sections before classification. If minNeighbors is 5, there must be 5 other parts, or sections, of a face around a certain section if that section can be classified as part of a face (because usually one part of the face is surrounded by other parts). If you make minNeighbors larger, than the model will be much more sure about the faces it detects but it might miss some faces. If you make this smaller, the model will detect more faces but it will also make more mistakes. \n\n* **minSize** is the minimum size a face must be in order for it to be viable for detection.  \n\nThe method will output the coordinates of all the faces found.\n\n","metadata":{"id":"FcClRtog9Fpf"},"pos":10,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"8f101c","input":"### Display the Results\n\nThe display will first output the length of the list of faces, or the number of faces, to the user. Then, for each of the face coordinates, cv2 will draw a green rectangle around the faces. Finally cv2_imshow function will display the main image with the rectangles drawn on top.\n\n","metadata":{"id":"g6MqDa0P9MVz"},"pos":12,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"a162e2","input":"### Dependencies\n\nFirst we will import the dependencies, or libraries, necessary for this project. The dependencies are OpenCV for the face detector, skimage for reading an image from a url, and pyplot for displaying the image in this notebook.\n\n","metadata":{"id":"6QPj94nu6zrE"},"pos":1,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"aebb0a","input":"# Let's Build An AI Face Detector!\n\nIn just a couple, simple lines you will be able to build your very own face detector where you can input a image url and the face detector will draw boxes around the faces before displaying the results of **AI face detection.**\n\n### Theory Behind the Model\nFirst the face detector splits the image into multiple small sections. For each section, it first runs a series of general facial tests. The sections that pass these tests move on to the next, more specific, facial tests and the ones that don't pass are disregarded. On the sections that the face detector is unsure about, it runs more and more tests (a total of 6000) until the face detector can be positive that the section is part of a face. It is like a cascade, or waterfall, of tests which is why the face detector we use is called a cascade classifier.","metadata":{"id":"npPdoLfV6RlL"},"pos":0,"state":"done","type":"cell"}
{"id":"e2d355","input":"","pos":16,"state":"done","type":"cell"}
{"id":0,"time":1658331455682,"type":"user"}
{"last_load":1658329970129,"type":"file"}